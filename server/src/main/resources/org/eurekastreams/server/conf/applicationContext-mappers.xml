<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.5.xsd">

	<!--
		**** Beans useful for multiple mappers (particularly in chained
		mappers) ****
	-->

	<!-- Results combiner - just returns the first non-null value -->
	<bean id="nonNullResultsCombiner"
		class="org.eurekastreams.server.persistence.mappers.chained.NonNullResultsCombiner" />

	<bean name="hashTagExtractor"
		class="org.eurekastreams.server.domain.strategies.HashTagExtractor" />

	<bean name="activityContentExtractor"
		class="org.eurekastreams.server.persistence.mappers.stream.ActivityContentExtractor" />
		
	<bean name="ignoredCacheKeySuffixTransformer" 
		class="org.eurekastreams.server.persistence.mappers.cache.IgnoredCacheKeySuffixTransformer" />
	
	<bean id="toStringCacheKeySuffixTransformer" 
		class="org.eurekastreams.server.persistence.mappers.cache.ToStringCacheKeySuffixTransformer" />
	
	<bean id="collectionCombiner" class="org.eurekastreams.server.persistence.mappers.chained.CollectionCombiner" />	
	
	<bean id="removeCachedPersonModelViewCacheMapper" class="org.eurekastreams.server.persistence.mappers.cache.RemoveCachedPersonModelViewCacheMapper">
		<property name="cache" ref="memcachedCache" />
	</bean>
	
	<bean id="clearActivityStreamSearchStringCacheOnGroupUpdate" class="org.eurekastreams.server.persistence.mappers.cache.ClearPrivateGroupIdsViewableByCoordinatorCacheOnGroupUpdate">
        <property name="cache" ref="memcachedCache" />
    </bean>
	
	<!-- ========== CACHE KEYS ========== -->
	
	<util:constant id="CacheKeys.ORG_IDS_DIRECTLY_COORD_BY_PERSON" static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ORG_IDS_DIRECTLY_COORD_BY_PERSON" />
	<util:constant id="CacheKeys.LIKERS_BY_RESOURCE_ID" static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.LIKERS_BY_RESOURCE_ID" />
	<util:constant id="CacheKeys.LIKERS_BY_ACTIVITY_ID" static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.LIKERS_BY_ACTIVITY_ID" />
	<util:constant id="CacheKeys.UNREAD_APPLICATION_ALERT_COUNT_BY_USER" static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.UNREAD_APPLICATION_ALERT_COUNT_BY_USER" />
	<util:constant id="CacheKeys.GROUP_BY_ID" static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_ID" />
	<util:constant id="CacheKeys.CRYPTO_KEY_BY_PERSON_ID" static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.CRYPTO_KEY_BY_PERSON_ID" />
	
	
	
	<!-- ========== PRINCIPAL DAOs ========== -->
	
    <bean id="dataStorePrincipalDao" class="org.eurekastreams.server.persistence.mappers.principal.DataStorePrincipalDao" >
        <constructor-arg ref="getPersonByAccountIdMapperAllowNullResult" />
        <constructor-arg ref="serviceActionController" />
        <constructor-arg ref="createPersonFromLdap" />
    </bean>

    <bean id="openSocialPrincipalDao" class="org.eurekastreams.server.persistence.mappers.principal.OpenSocialPrincipalDao">
        <constructor-arg ref="bulkPeopleByOpenSocialIdMapper" />
        <constructor-arg ref="getPersonByAccountIdMapper" />
    </bean>

    <bean id="openSocialPrincipalDaoTransWrapped" class="org.eurekastreams.server.persistence.mappers.MapperTransactionDecorator">
        <constructor-arg ref="openSocialPrincipalDao" />
        <constructor-arg ref="transactionManager" />
    </bean>


	
	
	<!--
		Mapper to get the hash tags from the database - insert if not already
		in the database
	-->
	<bean id="getHashTagsFromDatabaseMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<!-- Partial database mapper -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.PartialHashTagDbMapper" />
		</constructor-arg>

		<constructor-arg>
			<!--
				Hashtag generation mapper to create new ones if not found in the
				database
			-->
			<bean
				class="org.eurekastreams.server.persistence.mappers.HashTagBuilderMapper" />
		</constructor-arg>

		<constructor-arg ref="collectionCombiner" />

		<constructor-arg>
			<!-- Database refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.HashTagDbRefreshStrategy" />
		</constructor-arg>
	</bean>
	<!-- ****  **** -->

	<!--
		Wire up the entity updaters for person, domain group -
		handles onPostUpdate, onPostPersist
	-->
	<bean
		class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="targetObject">
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.CacheInitializer" />
		</property>
		<property name="targetMethod" value="wireCacheUpdaters" />
		<property name="arguments">
			<list>
				<ref bean="domainGroupEntityCacheUpdater" />
				<ref bean="personEntityCacheUpdater" />
			</list>
		</property>
	</bean>

	<bean id="getAllPluginsMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetAllPluginsMapper" />

	<bean id="getFeedSubscriptionsByEntity"
		class="org.eurekastreams.server.persistence.mappers.db.GetFeedSubscriptionsByEntity" />

	<bean id="getFeedSubscriberOrCreateMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetFeedSubscriberOrCreateMapper" />

	<bean id="getFeedByUrlOrCreateMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetFeedByUrlOrCreateMapper" />

	<bean id="getRefreshableFeedsMapper"
		class="org.eurekastreams.server.persistence.mappers.GetRefreshableFeedsMapper" />

	<bean id="setRefreshableFeedsAsPendingMapper"
		class="org.eurekastreams.server.persistence.mappers.SetRefreshableFeedsAsPending" />

	<bean id="deleteByIdMapper"
		class="org.eurekastreams.server.persistence.mappers.DeleteByIdMapper" />

	<bean id="deleteFeedSubscriberByIdMapper" class="org.eurekastreams.server.persistence.mappers.db.DeleteFeedSubscriberMapper" />

	<bean id="addBufferedActivitiesToCache"
		class="org.eurekastreams.server.persistence.mappers.cache.AddBufferedActivitiesToCache">
		<constructor-arg ref="bulkActivitiesMapper" />
		<constructor-arg ref="memcachedCache" />
		<constructor-arg ref="getPersonIdsFollowingActivityDestinationStreamMapper" />
		<constructor-arg ref="postActivityUpdateStreamsByActorMapper" />
	</bean>

	<bean id="jpaFeedReaderMapper" class="org.eurekastreams.server.persistence.FeedReaderMapper"></bean>

	<bean id="searchPeopleAndGroupsByPrefixMapper"
		class="org.eurekastreams.server.persistence.mappers.SearchPeopleAndGroupsByPrefix">
		<constructor-arg value="7" /> <!-- default max results -->
		<constructor-arg ref="groupPersonSearchRequestBuilder" />
		<constructor-arg
			ref="getPrivateCoordinatedAndFollowedGroupIdsForUserMapper" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
		<!-- exclude Read Only Streams from results-->
		<constructor-arg value="true" />
	</bean>

	<bean id="searchGroupsByPrefixMapper"
		class="org.eurekastreams.server.persistence.mappers.SearchPeopleAndGroupsByPrefix">
		<constructor-arg value="7" /> <!-- default max results -->
		<constructor-arg ref="groupSearchRequestBuilder" />
		<constructor-arg
			ref="getPrivateCoordinatedAndFollowedGroupIdsForUserMapper" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
		<!-- exclude Read Only Streams from results-->
		<constructor-arg value="true" />
	</bean>
	
    <bean id="searchPeopleAndGroupsByPrefixAllowReadOnlyStreamsMapper"
        class="org.eurekastreams.server.persistence.mappers.SearchPeopleAndGroupsByPrefix">
        <constructor-arg value="7" /> <!-- default max results -->
        <constructor-arg ref="groupPersonSearchRequestBuilder" />
        <constructor-arg
            ref="getPrivateCoordinatedAndFollowedGroupIdsForUserMapper" />
        <constructor-arg ref="getPersonIdByAccountIdMapper" />
        <!-- exclude Read Only Streams from results-->
        <constructor-arg value="false" />
    </bean>	
	
	<bean id="searchPeopleByPrefixAllowReadOnlyStreamsMapper"
        class="org.eurekastreams.server.persistence.mappers.SearchPeopleAndGroupsByPrefix">
        <constructor-arg value="7" /> <!-- default max results -->
        <constructor-arg ref="personSearchRequestBuilder" />
        <constructor-arg
            ref="getPrivateCoordinatedAndFollowedGroupIdsForUserMapper" />
        <constructor-arg ref="getPersonIdByAccountIdMapper" />
        <!-- exclude Read Only Streams from results-->
        <constructor-arg value="false" />
    </bean>

	<bean id="getPendingDomainGroupsMapper"
		class="org.eurekastreams.server.persistence.mappers.GetPendingDomainGroupsMapper">
		<property name="getPeopleByIdsMapper" ref="getPersonsByIdsMapper" />
	</bean>

	<bean id="activityOrCombiner"
		class="org.eurekastreams.server.persistence.mappers.chained.ListColliderAdapter">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.service.actions.strategies.activity.OrSortedListCollider" />
		</constructor-arg>
		<constructor-arg value="2000000" />
	</bean>

	<bean id="findByIdMapper"
		class="org.eurekastreams.server.persistence.mappers.FindByIdMapper">
		<property name="queryOptimizer" ref="queryOptimizer" />
	</bean>

	<bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITY_SECURITY_BY_ID"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
		
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />  
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ACCOUNT_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /> 
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_OPEN_SOCIAL_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />	
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PEOPLE_FOLLOWED_BY_PERSON"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />	
                
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
                
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_SHORT_NAME"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_PERSON"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />  
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUPS_FOLLOWED_BY_PERSON"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /> 
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_GROUP"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />    
                
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COORDINATOR_PERSON_IDS_BY_GROUP_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />  
        
    <bean
        id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_IDS_BY_ACTIVITY_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
        
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_BY_ID"
            class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />        
                           
	<bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.POPULAR_HASH_TAGS_BY_STREAM_TYPE_AND_SHORT_NAME"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.EVERYONE_ACTIVITY_IDS"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITIES_BY_FOLLOWING"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
		
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.TUTORIAL_VIDS"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />
        
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_PAGE_PROPERTIES_BY_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />        
        
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.APPDATA_BY_GADGET_DEFINITION_ID_AND_UNDERSCORE_AND_PERSON_OPEN_SOCIAL_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />   
        
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_CSS_BY_UUID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />  
        
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_HASH_BY_UUID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />                   

    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.STREAM_SCOPE_ID_BY_PERSON_ACCOUNT_ID"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />  
    
    <bean id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.STREAM_SCOPE_ID_BY_GROUP_SHORT_NAME"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />                 
    

	<!--
		Mapper that goes to cache for the popular hashtags for a stream.  If it exists, it checks how long ago it was generated. 
		If it was too long ago, it throws the cached value away and falls back to the database, then stores that result in cache.
	 -->
	<bean id="findPopularHashTagsForStreamMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		
		<!-- CACHE COMPONENT -->
		<constructor-arg>
			
			<!-- Cache mapper isn't partial results - wrap it -->
			<bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
				<constructor-arg>
				
					<!-- Get the value from cache, and check to make sure it's not too old
-->
					<bean class="org.eurekastreams.server.persistence.mappers.StreamPopularHashTagsMapper">		
						
						<!-- Use the reusable single-value cache mapper to get the value -->
						<constructor-arg>
							<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
								<!-- Transformer from stream populator hash tags request to cache key suffix -->
	
								<!-- Cache Key Prefix -->				
								<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.POPULAR_HASH_TAGS_BY_STREAM_TYPE_AND_SHORT_NAME" />

								<constructor-arg>
									<bean class="org.eurekastreams.server.persistence.mappers.cache.StreamPopularHashTagsRequestCacheKeySuffixTransformer" />
								</constructor-arg>
								
								<property name="cache" ref="memcachedCache" />
							</bean>
						</constructor-arg>
						
						<!-- Number of minutes that we keep popular hashtags in cache -->
						<constructor-arg value="${eureka.stream.popularhashtags.cachetimeoutinminutes}" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>
		
		<!-- DATABASE COMPONENT -->
		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean class="org.eurekastreams.server.persistence.mappers.db.StreamPopularHashTagsDbMapper">
			
				<!-- Number of minutes to look back for popular hashtags -->
				<constructor-arg value="${eureka.stream.popularhashtags.activitywindowinminutes}" />
				
				<!-- Max number of hashtags to return -->
				<constructor-arg value="${eureka.stream.popularhashtags.count}" />
			</bean>
		</constructor-arg>

		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		
		<!-- CACHE REFRESHER -->
		<constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
				<!-- Cache Key Prefix -->				
				<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.POPULAR_HASH_TAGS_BY_STREAM_TYPE_AND_SHORT_NAME" />

				<!-- Cache key suffix transformer -->
				<constructor-arg>
					<bean
						class="org.eurekastreams.server.persistence.mappers.cache.StreamPopularHashTagsRequestCacheKeySuffixTransformer" />
				</constructor-arg>

				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>



    <bean id="findPopularHashTagsForAllGroupsJoinedMapper"
        class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        
        <!-- CACHE COMPONENT -->

        <constructor-arg>
            <!-- Cache mapper isn't partial results - wrap it -->
                            <bean
                                class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                                <constructor-arg>
                                    <bean
                                        class="org.eurekastreams.server.persistence.mappers.cache.StreamPopularHashTagsRequestCacheKeySuffixTransformer" />
                                </constructor-arg>
                                <constructor-arg
                                    ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.POPULAR_HASH_TAGS_BY_STREAM_TYPE_AND_SHORT_NAME" />
                               <constructor-arg value="False" />
                                <property name="cache" ref="memcachedCache" />
                             </bean>
         </constructor-arg>
        <!-- DATABASE COMPONENT -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.MultiRequestMapperWrapper">
                    <constructor-arg>
                         <ref bean="findPopularHashTagsForStreamMapper" />
                    </constructor-arg>
            </bean>
        </constructor-arg>

        <constructor-arg ref="collectionCombiner" />
        
        <!-- CACHE REFRESHER -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.NullCacheRefresher" />
        </constructor-arg>
    </bean>

	<bean id="bulkActivitySecurityMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITY_SECURITY_BY_ID" />
				<constructor-arg value="False" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>

		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
				<constructor-arg>
					<bean
						class="org.eurekastreams.server.persistence.mappers.db.BulkActivitySecurityDbMapper" />
				</constructor-arg>
		
				<constructor-arg>
					<bean
						class="org.eurekastreams.server.persistence.mappers.BulkDeletedActivitySecurityMapper" />
				</constructor-arg>
		
				<constructor-arg ref="collectionCombiner" />
		
		        <constructor-arg>
		            <bean class="org.eurekastreams.server.persistence.mappers.cache.NullCacheRefresher" />
		        </constructor-arg>
			</bean>		
		</constructor-arg>

		<constructor-arg ref="collectionCombiner" />

		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.BulkActivitySecurityRefresher">
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="getUserStreamsMapper" class="org.eurekastreams.server.persistence.mappers.db.GetUserStreamsDbMapper" />

	<bean id="getUserBookmarksMapper" class="org.eurekastreams.server.persistence.mappers.db.GetUserBookmarksDbMapper" />

	<bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ENTITY_STREAM_BY_SCOPE_ID"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean id="bulkActivityStreamsMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ENTITY_STREAM_BY_SCOPE_ID" />
				<constructor-arg value="True" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>

		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.BulkActivityStreamsDbMapper">
					<property name="maxItems" value="2000000" />
			</bean>

		</constructor-arg>

		<constructor-arg ref="collectionCombiner" />

		<constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedCollectionCacheMapper">
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ENTITY_STREAM_BY_SCOPE_ID" />
				<!-- Cache Key Prefix -->				
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

    <bean id="getPeopleIdsByAccountIdsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetIdsFromPointersDbMapper">
        <constructor-arg value="accountId" />
        <constructor-arg value="org.eurekastreams.server.domain.Person" />
    </bean>
            
    <!-- Mapper to get people ids by account ids -->
    <bean id="getPeopleIdsByAccountIdsMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ACCOUNT_ID" />
                <constructor-arg value="False" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
        
        <!-- Database mapper -->
        <constructor-arg ref="getPeopleIdsByAccountIdsDbMapper" />
    
        <!-- Combiner -->
        <constructor-arg ref="collectionCombiner" />
    
        <!-- Refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.MultiSetKeyedSingleValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ACCOUNT_ID" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    
    <!-- Mapper to get people ids by open social ids -->
    <bean id="getPeopleIdsByOpenSocialIdsMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_OPEN_SOCIAL_ID" />
                <constructor-arg value="False" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
        
        <!-- Database mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetIdsFromPointersDbMapper">
                <constructor-arg value="openSocialId" />
                <constructor-arg value="org.eurekastreams.server.domain.Person" />
            </bean>
        </constructor-arg>
    
        <!-- Combiner -->
        <constructor-arg ref="collectionCombiner" />
    
        <!-- Refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.MultiSetKeyedSingleValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_OPEN_SOCIAL_ID" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    

    <!-- Mapper to get group ids by short name -->
    <bean id="getDomainGroupIdsByShortNamesMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_SHORT_NAME" />
                <constructor-arg value="False" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
        
        <!-- Database mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetIdsFromPointersDbMapper">
                <constructor-arg value="shortName" />
                <constructor-arg value="org.eurekastreams.server.domain.DomainGroup" />
            </bean>
        </constructor-arg>
    
        <!-- Combiner -->
        <constructor-arg ref="collectionCombiner" />
    
        <!-- Refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.MultiSetKeyedSingleValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_SHORT_NAME" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>

	<!-- Mapper to get group id by short name / unique id - throws exception when not found -->
	<bean id="getGroupIdByShortNameMapper" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
		<constructor-arg ref="getDomainGroupIdsByShortNamesMapper" />
		<constructor-arg value="true" />
	</bean>

	<!-- Mapper to get person id by account id - wraps getPeopleIdsByAccountIds - throws exception when not found -->
	<bean id="getPersonIdByAccountIdMapper" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
		<constructor-arg ref="getPeopleIdsByAccountIdsMapper" />
		<constructor-arg value="true" />
	</bean>

	<!-- Mapper to get people by account ids -->
	<bean id="getPeopleByAccountIdsMapper" class="org.eurekastreams.server.persistence.mappers.GetItemsByPointerIdsMapper">
		<!-- Mapper to get people ids from account ids -->
		<constructor-arg ref="getPeopleIdsByAccountIdsMapper" />
		
		<!-- mapper to look up people by ids -->
		<constructor-arg ref="getPersonsByIdsMapper" />
	</bean>

	<!-- Mapper to get person model view by account id - wraps getPeopleByAccountIdsMapper - throws exception when not found -->
	<bean id="getPersonByAccountIdMapper" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
		<constructor-arg ref="getPeopleByAccountIdsMapper" />
		<constructor-arg value="true" />
	</bean>
	
	<!-- Mapper to get person model view by account id - wraps getPeopleByAccountIdsMapper - returns null when not found -->
    <bean id="getPersonByAccountIdMapperAllowNullResult" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
        <constructor-arg ref="getPeopleByAccountIdsMapper" />
        <constructor-arg value="false" />
    </bean>

	<!-- Mappers to get person's account id by id. -->
	<bean id="getPersonAccountIdByIdMapper" class="org.eurekastreams.server.persistence.mappers.transform.UniqueIdFromIdMapper">
		<constructor-arg ref="getPersonByIdMapper" />
	</bean>
	<bean id="getPersonAccountIdByIdMapperAllowNull" class="org.eurekastreams.server.persistence.mappers.transform.UniqueIdFromIdMapper">
		<constructor-arg ref="getPersonByIdMapperAllowNullResult" />
	</bean>
	
	<!-- Mappers to get group's unique id by id. -->
	<bean id="getGroupUniqueIdByIdMapper" class="org.eurekastreams.server.persistence.mappers.transform.UniqueIdFromIdMapper">
		<constructor-arg ref="getGroupByIdMapper" />
	</bean>
	<bean id="getGroupUniqueIdByIdMapperAllowNull" class="org.eurekastreams.server.persistence.mappers.transform.UniqueIdFromIdMapper">
		<constructor-arg ref="getGroupByIdMapperAllowNullResult" />
	</bean>


	<bean id="findSystemSettings"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<!--
				Wrap the System Settings cache mapper with a partial mapper wrapper
			-->
			<bean
				class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
				<constructor-arg>
					<!-- Cache mapper to get the system settings -->
					<bean
						class="org.eurekastreams.server.persistence.mappers.cache.FindSystemSettingsCacheDomainMapperImpl">
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>

		<constructor-arg ref="findSystemSettingsFromDatabase" />

		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />

		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.RefreshSystemSettingsCacheMapperImpl">
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="findSystemSettingsFromDatabase"
		class="org.eurekastreams.server.persistence.mappers.db.FindSystemSettingsDbDomainMapperImpl">
		<constructor-arg ref="headerContentTemplate" />
		<constructor-arg ref="footerContentTemplate" />
		<constructor-arg ref="bannerContentTemplate" />
		<!--
			Mapper to get the system settings straight from the database - needed
			for updating it.
		-->
		<property name="queryOptimizer" ref="queryOptimizer" />
	</bean>
	
	<bean id="setSystemAdminsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.SetSystemAdminsDbMapper" />
	
	<bean id="getTutorialVideos" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
		    <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
		        <constructor-arg>
		            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
		                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.TUTORIAL_VIDS" />
		                <constructor-arg ref="ignoredCacheKeySuffixTransformer" />
		                <property name="cache" ref="memcachedCache" />
		            </bean>
		        </constructor-arg>
		    </bean>
	    </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetTutorialVideosDbMapper" />
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
		        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.TUTORIAL_VIDS" />
		        <constructor-arg ref="ignoredCacheKeySuffixTransformer" />
		        <property name="cache" ref="memcachedCache" />
		    </bean> 
	    </constructor-arg>       
    </bean>
    
    <bean id="getAppDataDTO" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.APPDATA_BY_GADGET_DEFINITION_ID_AND_UNDERSCORE_AND_PERSON_OPEN_SOCIAL_ID" />
                        <constructor-arg ref="getAppDataRequestToSuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetAppDataDTODbMapper">
                <constructor-arg ref="jpaAppDataMapper"/>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.APPDATA_BY_GADGET_DEFINITION_ID_AND_UNDERSCORE_AND_PERSON_OPEN_SOCIAL_ID" />
                <constructor-arg ref="getAppDataRequestToSuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean> 
    
    <bean id="getThemeCssByUuid" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_CSS_BY_UUID" />
                        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.ThemeCssDbMapper">
                <constructor-arg value="/org/eurekastreams/server/conf/schema/css.xslt"/>
                <constructor-arg ref="getThemeXmlUrlByUuidDbMapper"/>
                <constructor-arg>
		            <bean class="org.eurekastreams.server.service.actions.strategies.URLFetcher" />
		        </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_CSS_BY_UUID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>
    
    <bean id="getThemeCssByUuid_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.ThemeCssDbMapper">
                <constructor-arg value="/org/eurekastreams/server/conf/schema/css.xslt"/>
                <constructor-arg ref="getThemeXmlUrlByUuidDbMapper"/>
                <constructor-arg>
                    <bean class="org.eurekastreams.server.service.actions.strategies.URLFetcher" />
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_CSS_BY_UUID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>    
    
    <bean id="getThemeVersionByUuid" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_HASH_BY_UUID" />
                        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetThemeVersionByUuidDbMapper">
                <constructor-arg ref="getThemeCssByUuid"/>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_HASH_BY_UUID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>  
    
    <!-- This mapper will force refresh of BOTH theme version AND theme css as it is config'd with the 
    force refresh version of getThemeCssByUuid mapper.-->
    <bean id="getThemeVersionByUuid_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetThemeVersionByUuidDbMapper">
                <constructor-arg ref="getThemeCssByUuid_FORCE_REFRESH"/>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.THEME_HASH_BY_UUID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>      
    
    <bean id="getPersonPagePropertiesById" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_PAGE_PROPERTIES_BY_ID" />
                        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetPersonPagePropertiesByIdDbMapper">
                <constructor-arg ref="findByIdMapper" />
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.PersonToPersonPagePropertiesTransformer"/>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_PAGE_PROPERTIES_BY_ID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean> 
    
    <bean id="getPersonPagePropertiesById_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <constructor-arg ref="nullResultPartialMapper"/>
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetPersonPagePropertiesByIdDbMapper">
                <constructor-arg ref="findByIdMapper" />
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.PersonToPersonPagePropertiesTransformer"/>
                </constructor-arg>
            </bean>
        </constructor-arg>
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_PAGE_PROPERTIES_BY_ID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean> 
        </constructor-arg>       
    </bean>      
    
    <bean id="getAppDataRequestToSuffixTransformer" class="org.eurekastreams.server.persistence.mappers.cache.GetAppDataRequestToSuffixTransformer"/>   
    
	<bean id="saveDomainGroupCoordinatorsListToCacheMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.SaveDomainGroupCoordinatorsListToCache">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="findLinkInformationByUrlMapper"
		class="org.eurekastreams.server.persistence.mappers.FindLinkInformationByUrl">
		<property name="queryOptimizer" ref="queryOptimizer" />
		<property name="expirationInMilliseconds" value="7200000" />
	</bean>

	<bean id="insertStarredActivity"
		class="org.eurekastreams.server.persistence.mappers.InsertStarredActivity">
		<constructor-arg ref="getStarredActivityIds" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteStarredActivity"
		class="org.eurekastreams.server.persistence.mappers.DeleteStarredActivity">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="insertLikedActivity"
		class="org.eurekastreams.server.persistence.mappers.InsertLikedActivity">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteLikedActivity"
		class="org.eurekastreams.server.persistence.mappers.DeleteLikedActivity">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="getEveryoneActivityDbMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetEveryoneActivityDbMapper">
	</bean>
	<bean id="refreshFollowedByActivitiesCacheMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.RefreshFollowedByActivitiesCacheMapper">
		<property name="cache" ref="memcachedCache" />
	</bean>
	<bean id="getFollowedByActivitiesDbMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetFollowedByActivitiesDbMapper">
		<constructor-arg ref="followedActivityIdsLoader" />
		
		<!-- Limit how many following activity ids we get from the database -->
		<constructor-arg value="10000" />
	</bean>
	
	<bean id="getAllFollowedByActivityIds" class="org.eurekastreams.server.persistence.mappers.composite.GetAllFollowedByActivityIdsMapper">
		<constructor-arg ref="getFollowedByActivities" />
		<constructor-arg ref="bulkActivityStreamsMapper" />
	</bean>

	<bean id="getFollowedByActivities"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<!-- Wrap the cache mapper with a partial mapper wrapper -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
				<constructor-arg>
					<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
						<constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITIES_BY_FOLLOWING" />
						<constructor-arg ref="toStringCacheKeySuffixTransformer" />
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>

		<!-- Database mapper to fall back on if not found in cache -->
		<constructor-arg ref="getFollowedByActivitiesDbMapper" />

		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />

		<!-- Cache refresher -->
		<constructor-arg ref="refreshFollowedByActivitiesCacheMapper" />
	</bean>
		
	<bean id="getGroupCoordinatorIdsByGroupIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getGroupCoordinatorIdsByGroupIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getGroupCoordinatorIdsByGroupIdCacheRefresher"/>                      
    </bean>
    
    <bean id="getGroupCoordinatorIdsByGroupIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getGroupCoordinatorIdsByGroupIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getGroupCoordinatorIdsByGroupIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getGroupCoordinatorIdsByGroupIdCacheRefresher"/>                       
    </bean>
    
    <bean id="getGroupCoordinatorIdsByGroupIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COORDINATOR_PERSON_IDS_BY_GROUP_ID" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>
    
    <bean id="getGroupCoordinatorIdsByGroupIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
		    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
		        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COORDINATOR_PERSON_IDS_BY_GROUP_ID" />
		        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
		        <property name="cache" ref="memcachedCache" />
		    </bean>
	    </constructor-arg>
    </bean> 
    
   <bean id="getOrderedCommentIdsByActivityIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getOrderedCommentIdsByActivityIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getOrderedCommentIdsByActivityIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getOrderedCommentIdsByActivityIdCacheRefresher"/>                       
    </bean>
    
    <bean id="getOrderedCommentIdsByActivityIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_IDS_BY_ACTIVITY_ID" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>
    
    <bean id="getOrderedCommentIdsByActivityIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_IDS_BY_ACTIVITY_ID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>    
	
	<bean id="getFollowedByActivities_FORCE_REFRESH"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg ref="nullResultPartialMapper" />

		<!-- Database mapper to fall back on if not found in cache -->
		<constructor-arg ref="getFollowedByActivitiesDbMapper" />

		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />

		<!-- Cache refresher -->
		<constructor-arg ref="refreshFollowedByActivitiesCacheMapper" />
	</bean>
	
	<bean id="getGroupsByIdsMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getGroupsByIdsDbMapper" />
        <!-- Results combiner -->
        <constructor-arg ref="collectionCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="groupCacheRefresher"/>                        
    </bean> 
    
    <bean id="getGroupsByIdsMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getGroupsByIdsCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getGroupsByIdsDbMapper" />
        <!-- Results combiner -->
        <constructor-arg ref="collectionCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="groupCacheRefresher"/>                        
    </bean>     
    
    <bean id="getGroupsByIdsCacheMapper" class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_ID" />
        <!-- Is list of lists flag -->
        <constructor-arg value="False" />
        <property name="cache" ref="memcachedCache" />
    </bean>        

	<!-- Mapper to get a group by id, throwing exception when not found -->
	<bean id="getGroupByIdMapper" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
		<constructor-arg ref="getGroupsByIdsMapper" />
		<constructor-arg value="true" />
	</bean>
	
	<!-- Mapper to get a group by id, returning null when not found -->
	<bean id="getGroupByIdMapperAllowNullResult" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
		<constructor-arg ref="getGroupsByIdsMapper" />
		<constructor-arg value="false" />
	</bean>
	
	<bean id="getFollowedGroupIdsForPersonByIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdCacheRefresher" />                       
    </bean>
    
    <bean id="getFollowedGroupIdsForPersonByIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdCacheRefresher" />                       
    </bean>   
    
    <bean id="getFollowedGroupIdsForPersonByIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUPS_FOLLOWED_BY_PERSON" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    
    <bean id="getFollowedGroupIdsForPersonByIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUPS_FOLLOWED_BY_PERSON" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>    
    
    <bean id="getFollowerPersonIdsForGroupByIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowerPersonIdsForGroupByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowerPersonIdsForGroupByIdCacheRefresher"/>                       
    </bean>    
    
    <bean id="getFollowerPersonIdsForGroupByIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getFollowerPersonIdsForGroupByIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowerPersonIdsForGroupByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowerPersonIdsForGroupByIdCacheRefresher"/>                       
    </bean> 
    
    <bean id="getFollowerPersonIdsForGroupByIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_GROUP" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>         
        
    <bean id="getFollowerPersonIdsForGroupByIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_GROUP" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>    
	

    <bean id="getFollowedPersonIdsForPersonByIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdCacheRefresher"/>                       
    </bean>
        
    <bean id="getFollowedPersonIdsForPersonByIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdCacheRefresher"/>                        
    </bean> 
    
    <bean id="getFollowedPersonIdsForPersonByIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PEOPLE_FOLLOWED_BY_PERSON" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>    
    
    <bean id="getFollowedPersonIdsForPersonByIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PEOPLE_FOLLOWED_BY_PERSON" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>             
    
    <bean id="getFollowerPersonIdsForPersonByIdMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdCacheRefresher"/>                       
    </bean>
        
    <bean id="getFollowerPersonIdsForPersonByIdMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdDbMapper" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdCacheRefresher"/>                       
    </bean> 
    
    <bean id="getFollowerPersonIdsForPersonByIdCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_PERSON" />
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <property name="cache" ref="memcachedCache" />
    </bean>    
    
    <bean id="getFollowerPersonIdsForPersonByIdCacheMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.FOLLOWERS_BY_PERSON" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>        

    <bean id="getPersonsByIdsMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="getPersonsByIdsCacheMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getPersonsByIdsDBMapper" />
        <!-- Results combiner -->
        <constructor-arg ref="collectionCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="personCacheRefresher"/>                        
    </bean>
    
	<!-- Mapper to get a person by id, throwing exception when not found -->
	<bean id="getPersonByIdMapper" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
		<constructor-arg ref="getPersonsByIdsMapper" />
		<constructor-arg value="true" />
	</bean>

	<!-- Mapper to get a person by id, returning null when not found -->
	<bean id="getPersonByIdMapperAllowNullResult" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
		<constructor-arg ref="getPersonsByIdsMapper" />
		<constructor-arg value="false" />
	</bean>
    
    <bean id="getPersonsByIdsMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg ref="getPersonsByIdsDBMapper" />
        <!-- Results combiner -->
        <constructor-arg ref="collectionCombiner" />
        <!-- Cache refresher -->
        <constructor-arg ref="personCacheRefresher"/>                        
    </bean>    
    
    <bean id="getPersonsByIdsCacheMapper" class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ID" />
        <!-- Is list of lists flag -->
        <constructor-arg value="False" />
        <property name="cache" ref="memcachedCache" />
    </bean>
    
    <bean id="personCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiRefreshCacheRefreshStrategy">
        <constructor-arg>
            <list>
                <ref local="personByIdRefresher" />
                <ref local="personByAccountIdRefresher" />
                <ref local="personByOpenSocialIdRefresher" />
            </list>
        </constructor-arg>
    </bean>       
    
    <bean id="personByIdRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ID" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="passThroughTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />        
    </bean>     
    
    <bean id="personByAccountIdRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_ACCOUNT_ID" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="personToAccountIdTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />      
    </bean>   
    
    <bean id="personByOpenSocialIdRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PERSON_BY_OPEN_SOCIAL_ID" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="personToOpenSocialIdTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />      
    </bean> 
    
    <bean id="groupCacheRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiRefreshCacheRefreshStrategy">
        <constructor-arg>
            <list>
                <ref local="groupByIdRefresher" />
                <ref local="groupByShortNameRefresher" />
            </list>
        </constructor-arg>
    </bean>  
    
    <bean id="groupByIdRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_ID" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="passThroughTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />      
    </bean>
    
    <bean id="groupByShortNameRefresher" class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
        <!-- Prefix -->
        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.GROUP_BY_SHORT_NAME" />
        <!-- Suffix Transformer -->
        <constructor-arg ref="groupToShortNameTransformer"/>
         <!-- Value Transformer -->
        <constructor-arg ref="modelViewToIdTransformer"/>
        <!-- Cache -->
        <constructor-arg ref="memcachedCache" />      
    </bean> 
        
    <bean id="modelViewToIdTransformer" class="org.eurekastreams.server.persistence.mappers.cache.ModelViewToIdTransformer" />
        
    <bean id="groupToShortNameTransformer" class="org.eurekastreams.server.persistence.mappers.cache.GroupToShortNameTransformer" />    
    
    <bean id="personToAccountIdTransformer" class="org.eurekastreams.server.persistence.mappers.cache.PersonToAccountIdTransformer" />
    
    <bean id="personToOpenSocialIdTransformer" class="org.eurekastreams.server.persistence.mappers.cache.PersonToOpenSocialIdTransformer" />
    
    <bean id="passThroughTransformer" class="org.eurekastreams.server.persistence.mappers.cache.PassThroughTransformer" />	
    
    <bean id="nullResultPartialMapper" class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.NullMapper">
            </bean>
        </constructor-arg>
    </bean>
    
    <bean id="personEntityCacheUpdater" class="org.eurekastreams.server.persistence.mappers.cache.PersonEntityCacheUpdater">
        <property name="cache" ref="memcachedCache" />
    </bean>
        
    <bean id="domainGroupEntityCacheUpdater" class="org.eurekastreams.server.persistence.mappers.cache.DomainGroupEntityCacheUpdater">
        <property name="cache" ref="memcachedCache" />
    </bean>    

	<bean id="getStreamScopeById"
		class="org.eurekastreams.server.persistence.mappers.GetStreamScopeById" />

	<bean id="getStreamScopeProxyById" class="org.eurekastreams.server.persistence.mappers.db.GetPlaceholderEntityMapper">
		<constructor-arg value="org.eurekastreams.server.domain.stream.StreamScope" />
	</bean>

	<bean id="followedActivityIdsLoader"
		class="org.eurekastreams.server.persistence.mappers.cache.FollowedActivityIdsLoaderImpl" />
		
	<bean id="activityIdSearchPageFetcherFactory"
		class="org.eurekastreams.server.search.stream.ActivityIdSearchPageFetcherFactory">
		<constructor-arg value="5" />
	</bean>

	<bean id="luceneActivityDataSource"
		class="org.eurekastreams.server.service.actions.strategies.activity.datasources.LuceneDataSource">
		<!-- DataSource for searching activities -->

		<constructor-arg>
			<bean
				class="org.eurekastreams.commons.search.ProjectionSearchRequestBuilder">
				<property name="resultFields">
					<list>
						<value>id</value>
					</list>
				</property>
				<property name="resultTypes">
					<list>
						<value>org.eurekastreams.server.domain.stream.Activity
						</value>
					</list>
				</property>
				<property name="queryParserBuilder">
					<bean class="org.eurekastreams.commons.search.QueryParserBuilder">
						<constructor-arg value="content" />
						<constructor-arg>
							<bean
								class="org.eurekastreams.commons.search.analysis.HashTagTextStemmerSearchAnalyzer" />
						</constructor-arg>
						<constructor-arg value="AND" />
					</bean>
				</property>
				<property name="advancedQueryParserBuilder">
					<bean class="org.eurekastreams.commons.search.QueryParserBuilder">
						<constructor-arg value="content" />
						<constructor-arg>
							<bean
								class="org.eurekastreams.commons.search.analysis.HashTagTextStemmerSearchAnalyzer" />
						</constructor-arg>
						<constructor-arg value="AND" />
					</bean>
				</property>
				<property name="resultTransformer">
					<bean
						class="org.eurekastreams.commons.hibernate.SingleFieldResultTransformer">
						<property name="fieldName" value="id" />
					</bean>
				</property>
			</bean>
		</constructor-arg>
		<constructor-arg>
			<bean
				class="org.eurekastreams.commons.search.ProjectionSearchRequestBuilder">
				<property name="resultFields">
					<list>
						<value>id</value>
					</list>
				</property>
				<property name="resultTypes">
					<list>
						<value>org.eurekastreams.server.domain.stream.Activity
						</value>
					</list>
				</property>
				<property name="queryParserBuilder">
				    <bean id="unstemmedActivityResultsQueryBuilder" class="org.eurekastreams.commons.search.QueryParserBuilder"
				        scope="prototype">
				        <constructor-arg value="_hibernate_class" />
				        <constructor-arg>
				            <bean class="org.apache.lucene.analysis.WhitespaceAnalyzer" />
				        </constructor-arg>
				        <constructor-arg value="AND" />
				    </bean>
				</property>
				<property name="resultTransformer">
					<bean
						class="org.eurekastreams.commons.hibernate.SingleFieldResultTransformer">
						<property name="fieldName" value="id" />
					</bean>
				</property>
			</bean>
		</constructor-arg>
		<constructor-arg>
			<map>
				<entry key="keywords" value="content" />
				<entry key="authoredBy" value="author" />
				<entry key="fromApp" value="appId" />
			</map>
		</constructor-arg>
		<constructor-arg>
        	<map>
				<entry key="authoredBy">
					<bean 
                       class="org.eurekastreams.server.service.actions.strategies.activity.datasources.AuthoredByPersistenceRequestTransformer">
                       <constructor-arg ref="getPersonIdByAccountIdMapper" />   
                       <constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
                    </bean>
				</entry>
				<entry key="fromApp">
					<bean class="org.eurekastreams.server.service.actions.strategies.activity.datasources.AppSourcePersistenceRequestTransformer" />
				</entry>
			</map>
		</constructor-arg>		
		<constructor-arg value="2000000" />
	</bean>

    <bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITY_BY_ID"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean id="bulkActivitiesMapper"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.ACTIVITY_BY_ID" />
				<constructor-arg value="False" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>

		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.stream.BulkActivitiesDbMapper">
				<constructor-arg ref="getPersonByAccountIdMapper" /> 
				<constructor-arg ref="getPeopleByAccountIdsMapper" />
				<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
				<constructor-arg ref="getOrderedCommentIdsByActivityIdMapper" />
				<constructor-arg ref="getCommentsById" />
			</bean>
		</constructor-arg>

		<constructor-arg ref="collectionCombiner" />

		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.BulkActivityRefresher">
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="getPrivateGroupsByUserIdSource"
		class="org.eurekastreams.server.persistence.mappers.GetPrivateGroupsByUserId">
		<constructor-arg ref="getPrivateGroupIdsCoordinatedByPersonMapper" />
		<constructor-arg>
		      <bean class="org.eurekastreams.server.persistence.mappers.db.GetAllPrivateGroupIdsDbMapper" />
		</constructor-arg>
		<constructor-arg ref="getSystemAdministratorIds" />
	</bean>

	<bean id="baseGetPrivateGroupsByUserIdCacheHandling" abstract="true">
		<constructor-arg>
			<util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.PRIVATE_GROUP_IDS_VIEWABLE_BY_PERSON_AS_COORDINATOR" />
		</constructor-arg>
		<constructor-arg ref="toStringCacheKeySuffixTransformer" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="getPrivateGroupsByUserId" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<!-- Cache mapper -->
		<constructor-arg>
		    <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
		       <constructor-arg>
					<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper" parent="baseGetPrivateGroupsByUserIdCacheHandling" />
				</constructor-arg>
			</bean>
		</constructor-arg>
		<!-- Database mapper -->
		<constructor-arg ref="getPrivateGroupsByUserIdSource" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		<!-- Cache updater -->
		<constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy" parent="baseGetPrivateGroupsByUserIdCacheHandling" />
	    </constructor-arg>       
	</bean>
	
	<bean id="getPrivateGroupsByUserId_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<!-- Cache mapper -->
		<constructor-arg ref="nullResultPartialMapper" />
		<!-- Database mapper -->
		<constructor-arg ref="getPrivateGroupsByUserIdSource" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		<!-- Cache updater -->
		<constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy" parent="baseGetPrivateGroupsByUserIdCacheHandling" />
	    </constructor-arg>       
	</bean>


	<bean id="addPrivateGroupIdToCachedCoordinatorAccessList"
		class="org.eurekastreams.server.persistence.mappers.cache.AddPrivateGroupIdToCachedCoordinatorAccessList">
		<constructor-arg ref="getAllPersonIdsWhoHaveGroupCoordinatorAccess" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="getPrivateGroupIdsFromDB"
		class="org.eurekastreams.server.persistence.mappers.db.GetPrivateGroupIds" />

	<bean id="getAllPersonIdsWhoHaveGroupCoordinatorAccess"
		class="org.eurekastreams.server.persistence.mappers.GetAllPersonIdsWhoHaveGroupCoordinatorAccess">
		<constructor-arg ref="getGroupCoordinatorIdsByGroupIdMapper" />
		<constructor-arg ref="getGroupsByIdsMapper" />
		<constructor-arg ref="getSystemAdministratorIds" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
	</bean>


	<bean id="commentDeletePropertyStrategy"
		class="org.eurekastreams.server.persistence.strategies.CommentDeletePropertyStrategy">
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
		<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
		<constructor-arg ref="getAllPersonIdsWhoHaveGroupCoordinatorAccess" />
		<constructor-arg ref="getSystemAdministratorIds" />
	</bean>

	<bean id="activityDeletePropertyStrategy"
		class="org.eurekastreams.server.persistence.strategies.ActivityDeletePropertyStrategy">
		<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
		<constructor-arg ref="getAllPersonIdsWhoHaveGroupCoordinatorAccess" />
		<constructor-arg ref="getSystemAdministratorIds" />
	</bean>

	<bean id="personQueryStrategy"
		class="org.eurekastreams.server.persistence.strategies.PersonQueryStrategy" />

	<bean id="domainGroupQueryStrategy"
		class="org.eurekastreams.server.persistence.strategies.DomainGroupQueryStrategy" />

	<bean id="bulkPeopleByOpenSocialIdMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.GetPeopleByOpenSocialIds">
		<property name="bulkPeopleMapper" ref="getPersonsByIdsMapper" />
		<property name="idsByStringsMapper" ref="getPeopleIdsByOpenSocialIdsMapper" />
	</bean>
	
	<bean id="bulkDomainGroupsByShortNameMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.GetDomainGroupsByShortNames">
		<property name="bulkDomainGroupsMapper" ref="getGroupsByIdsMapper" />
		<property name="idsByStringsMapper" ref="getDomainGroupIdsByShortNamesMapper" />
	</bean>
	
    <bean id="getCommentsById"
        class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <constructor-arg>
            <bean
                class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <constructor-arg
                    ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_BY_ID" />
                <constructor-arg value="False" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>

        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetCommentsByIdsDbMapper">
                <constructor-arg ref="commentDTOPopulator" />
            </bean>
        </constructor-arg>

        <constructor-arg ref="collectionCombiner" />

        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.MultiValueCacheRefreshStrategy">
                <!-- Prefix -->
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.COMMENT_BY_ID" />
                <!-- Suffix Transformer -->
                <constructor-arg ref="modelViewToIdTransformer"/>
                 <!-- Value Transformer -->
                <constructor-arg ref="passThroughTransformer"/>
                <!-- Cache -->
                <constructor-arg ref="memcachedCache" />        
            </bean>
        </constructor-arg>
    </bean>
    
    <!-- gets single comment DTO by id, returns null if exactly one result not found. -->
    <bean id="getCommentByIdAllowNoneDAO" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
        <constructor-arg ref="getCommentsById" />
        <constructor-arg value="false" />
    </bean>

	<bean id="deleteActivityComment"
		class="org.eurekastreams.server.persistence.mappers.stream.DeleteActivityComment">
		<constructor-arg ref="getCommentsById" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteActivity"
		class="org.eurekastreams.server.persistence.mappers.stream.DeleteActivity">
		<constructor-arg ref="bulkActivitiesMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteActivityCacheUpdateDAO"
		class="org.eurekastreams.server.persistence.mappers.stream.DeleteActivityCacheUpdate">
		<constructor-arg ref="getFollowerPersonIdsForPersonByIdMapper" />
		<constructor-arg ref="getFollowerPersonIdsForGroupByIdMapper" />
		<constructor-arg ref="getPersonByAccountIdMapper" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
		<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />
		<constructor-arg ref="getPeopleWhoLikedActivity" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="getPersonIdsWithStarredActivity"
		class="org.eurekastreams.server.persistence.mappers.stream.GetPersonIdsWithStarredActivity">
		<property name="queryOptimizer" ref="queryOptimizer" />
	</bean>

	<bean id="getStarredActivityIds"
		class="org.eurekastreams.server.persistence.mappers.stream.GetStarredActivityIds">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean
		id="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.LIKED_BY_PERSON_ID"
		class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" />

	<bean id="getLikedActivityIdsByUserId"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.LIKED_BY_PERSON_ID" />
				<constructor-arg value="True" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>

		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.GetLikedActivityIdsByUserIdsDbMapper" />
		</constructor-arg>

		<constructor-arg ref="collectionCombiner" />

		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedCollectionCacheMapper">
				<constructor-arg
					ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.LIKED_BY_PERSON_ID" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="addCachedPersonFollower"
		class="org.eurekastreams.server.persistence.mappers.cache.AddCachedPersonFollower">
		<constructor-arg ref="getFollowedPersonIdsForPersonByIdMapper" />
		<constructor-arg ref="getFollowerPersonIdsForPersonByIdMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="addCachedGroupFollower"
		class="org.eurekastreams.server.persistence.mappers.cache.AddCachedGroupFollower">
		<constructor-arg ref="getFollowedGroupIdsForPersonByIdMapper" />
		<constructor-arg ref="getFollowerPersonIdsForGroupByIdMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="insertActivityComment"
		class="org.eurekastreams.server.persistence.mappers.stream.InsertActivityComment">
		<constructor-arg ref="commentDTOPopulator" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="commentDTOPopulator"
		class="org.eurekastreams.server.persistence.mappers.cache.cachedfieldpopulators.CommentDTOPopulator">
		<constructor-arg ref="getPersonsByIdsMapper" />
	</bean>

	<bean id="getPersonIdsFollowingActivityDestinationStreamMapper"
		class="org.eurekastreams.server.persistence.mappers.GetPersonIdsFollowingActivityDestinationStreamMapper">
		<constructor-arg ref="getFollowerPersonIdsForPersonByIdMapper" />
		<constructor-arg ref="getPersonIdByAccountIdMapper" />
	</bean>

	<bean id="postCachedActivity"
		class="org.eurekastreams.server.persistence.mappers.stream.PostCachedActivity">
		<constructor-arg ref="getFollowerPersonIdsForPersonByIdMapper" />
		<constructor-arg ref="getPersonByAccountIdMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="postActivityUpdateStreamsByActorMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.PostActivityUpdateStreamsByActorMapper">
		<constructor-arg ref="getPersonByAccountIdMapper" />
		<constructor-arg ref="bulkDomainGroupsByShortNameMapper" />	
		<constructor-arg ref="getStreamScopeForResourceScopeTypeByUniqueKeyExceptionIfNotFound" />			
		<property name="cache" ref="memcachedCache" />
	</bean>
	
	<bean id="hideResourceActivityMapper" class="org.eurekastreams.server.persistence.mappers.db.HideResourceActivityMapper">            
        <property name="cache" ref="memcachedCache" />
    </bean>
	
    <bean id="hideResourceActivityCacheUpdateMapper" class="org.eurekastreams.server.persistence.mappers.cache.HideResourceActivityCacheUpdateMapper">
        <constructor-arg ref="activityDTOMapper" />
        <constructor-arg ref="getPersonByAccountIdMapper" />         
        <constructor-arg ref="getFollowerPersonIdsForPersonByIdMapper" />            
        <property name="cache" ref="memcachedCache" />
    </bean>

	<bean id="gadgetUserPrefMapper"
		class="org.eurekastreams.server.persistence.mappers.opensocial.GetGadgetUserPrefMapper">
	</bean>
	
	<bean id="getPrivateGroupIdsCoordinatedByPersonMapper"
		class="org.eurekastreams.server.persistence.mappers.GetPrivateGroupIdsCoordinatedByPerson" />

	<bean id="getPrivateCoordinatedAndFollowedGroupIdsForUserMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.GetPrivateCoordinatedAndFollowedGroupIdsForUser">
		<constructor-arg ref="getPrivateGroupsByUserId" />
		<constructor-arg ref="getFollowedGroupIdsForPersonByIdMapper" />
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="buildActivityStreamSearchStringForUserMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.BuildActivityStreamSearchStringForUser">
		<constructor-arg
			ref="getPrivateCoordinatedAndFollowedGroupIdsForUserMapper" />
	</bean>

	<bean id="getActivityIdsAuthoredByOrOriginallyAuthoredByEntityDBMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetActivityIdsAuthoredByOrOriginallyAuthoredByEntity" />

	<bean id="getActivityCommentIdsAuthoredByPersonIdDBMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetActivityCommentIdsAuthoredByPersonId" />

	<bean id="getActivityIdsWithFirstOrLastCommentsAuthoredByPersonIdDBMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetActivityIdsWithFirstOrLastCommentsAuthoredByPersonId" />

	<bean id="getCommentorIdsByActivityId"
		class="org.eurekastreams.server.persistence.mappers.db.GetCommentorIdsByActivityId" />

	<bean id="getTabPermissionByPersonAndTabMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetTabPermissionByPersonAndTab">
	</bean>

	<bean id="getUnreadInAppNotificationCountsByUserId" 
		class="org.eurekastreams.server.persistence.mappers.db.notification.GetUnreadInAppNotificationCountsByUserId">
		<property name="queryOptimizer" ref="queryOptimizer" />
	</bean>
		
	<bean id="getCachedUnreadInAppNotificationCountsByUserId" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<!-- Cache mapper -->
		<constructor-arg>
		    <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
		       <constructor-arg>
					<bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
						<constructor-arg ref="CacheKeys.UNREAD_APPLICATION_ALERT_COUNT_BY_USER" />
						<constructor-arg ref="toStringCacheKeySuffixTransformer" />
						<property name="cache" ref="memcachedCache" />
					</bean>
				</constructor-arg>
			</bean>
		</constructor-arg>
		<!-- Database mapper -->
		<constructor-arg ref="getUnreadInAppNotificationCountsByUserId" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		<!-- Cache updater -->
		<constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
				<constructor-arg ref="CacheKeys.UNREAD_APPLICATION_ALERT_COUNT_BY_USER" />
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<property name="cache" ref="memcachedCache" />
		    </bean> 
	    </constructor-arg>       
	</bean>
	
	<bean id="getCachedUnreadInAppNotificationCountsByUserId_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<!-- Cache mapper -->
		<constructor-arg ref="nullResultPartialMapper" />
		<!-- Database mapper -->
		<constructor-arg ref="getUnreadInAppNotificationCountsByUserId" />
		<!-- Results combiner:  return whichever is not null -->
		<constructor-arg ref="nonNullResultsCombiner" />
		<!-- Cache updater -->
		<constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
				<constructor-arg ref="CacheKeys.UNREAD_APPLICATION_ALERT_COUNT_BY_USER" />
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<property name="cache" ref="memcachedCache" />
		    </bean> 
	    </constructor-arg>       
	</bean>
	
	<bean id="deleteGroupActivity"
		class="org.eurekastreams.server.persistence.mappers.db.DeleteGroupActivity" />

	<bean id="removeGroupFollowers"
		class="org.eurekastreams.server.persistence.mappers.db.RemoveGroupFollowers" />

	<bean id="deleteGroupSubscriptions"
		class="org.eurekastreams.server.persistence.mappers.db.DeleteAllFeedSubscriberByEntityTypeAndId" />

	<bean id="deleteGroup"
		class="org.eurekastreams.server.persistence.mappers.db.DeleteGroup">
		<constructor-arg ref="findByIdMapper" />
	</bean>

	<bean id="updateActivityFlagMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.UpdateActivityFlag" />

	<bean id="getFlaggedActivitiesMapper"
		class="org.eurekastreams.server.persistence.mappers.stream.GetFlaggedActivities">
		<constructor-arg ref="bulkActivitiesMapper" />
	</bean>

	<bean id="getExpiredActivities"
		class="org.eurekastreams.server.persistence.mappers.db.GetExpiredActivities" />

	<bean id="removeExpiredActivities"
		class="org.eurekastreams.server.persistence.mappers.cache.RemoveExpiredActivities">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="removeIdsFromLists"
		class="org.eurekastreams.server.persistence.mappers.cache.RemoveIdsFromLists">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteSystemSettingsCacheMapper"
		class="org.eurekastreams.server.persistence.mappers.cache.DeleteSystemSettingsCacheMapper">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteCacheKeys"
		class="org.eurekastreams.server.persistence.mappers.cache.DeleteCacheKeys">
		<property name="cache" ref="memcachedCache" />
	</bean>

	<bean id="deleteFromSearchIndex"
		class="org.eurekastreams.server.persistence.mappers.DeleteFromSearchIndex" />

    <bean id="updatePersonMapper"
        class="org.eurekastreams.server.persistence.mappers.db.UpdatePersonMapper" />
        
	<bean id="indexEntity"
		class="org.eurekastreams.server.persistence.mappers.IndexEntity" />


	<bean id="getPeopleWhoLikedActivity"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg ref="CacheKeys.LIKERS_BY_ACTIVITY_ID" />
				<constructor-arg value="True" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.GetPeopleWhoLikedActivityDbMapper" />
		</constructor-arg>
		<constructor-arg ref="collectionCombiner" />
		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedCollectionCacheMapper">
				<constructor-arg ref="CacheKeys.LIKERS_BY_ACTIVITY_ID" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<bean id="getPeopleWhoLikedResource"
		class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		<constructor-arg>
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.PartialCacheResultsMapper">
				<constructor-arg ref="toStringCacheKeySuffixTransformer" />
				<constructor-arg ref="CacheKeys.LIKERS_BY_RESOURCE_ID" />
				<constructor-arg value="True" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
		<constructor-arg>
			<!-- Database mapper to fall back on if not found in cache -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.db.GetPeopleWhoLikedResourceDbMapper" />
		</constructor-arg>
		<constructor-arg ref="collectionCombiner" />
		<constructor-arg>
			<!-- Cache refresher -->
			<bean
				class="org.eurekastreams.server.persistence.mappers.cache.SetKeyedCollectionCacheMapper">
				<constructor-arg ref="CacheKeys.LIKERS_BY_RESOURCE_ID" />
				<property name="cache" ref="memcachedCache" />
			</bean>
		</constructor-arg>
	</bean>

	<!-- Begin ldap mappers -->

	<bean id="findLdapGroupByCnNameMapper"
		class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
		<constructor-arg ref="searchStringLdapTemplateRetriever" />
		<constructor-arg ref="findLdapGroupByCnFilter" />
		<constructor-arg ref="ldapToLdapGroupCallbackFactory" />
		<constructor-arg ref="pagedLdapSearchStrategy" />
	</bean>

	<bean id="findLdapGroupByLdapGroupMembershipMapper"
		class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
		<constructor-arg ref="ldapGroupDnLdapTemplateRetriever" />
		<constructor-arg ref="findLdapGroupByMembershipFilter" />
		<constructor-arg ref="ldapToLdapGroupCallbackFactory" />
		<constructor-arg ref="pagedLdapSearchStrategy" />
	</bean>

	<bean id="findPersonByProvidedLdapQueryMapper"
		class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
		<constructor-arg ref="searchStringLdapTemplateRetriever" />
		<constructor-arg ref="findPersonByAttributeQueryFilter" />
		<constructor-arg ref="ldapToPersonCallbackFactory" />
		<constructor-arg ref="pagedLdapSearchStrategy" />
	</bean>

	<bean id="findPersonByCnWildcardMapper"
		class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
		<constructor-arg ref="searchStringLdapTemplateRetriever" />
		<constructor-arg ref="findPersonByCnWildcardFilter" />
		<constructor-arg ref="ldapToPersonCallbackFactory" />
		<constructor-arg ref="pagedLdapSearchStrategy" />
	</bean>
	
    <bean id="findPersonByAccountIdMapper"
        class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
        <constructor-arg ref="searchStringLdapTemplateRetriever" />
        <constructor-arg ref="findPersonByAccountIdFilter" />
        <constructor-arg ref="ldapToPersonCallbackFactory" />
        <constructor-arg ref="pagedLdapSearchStrategy" />
    </bean>	

	<bean id="findPersonByDirectLdapGroupMembershipMapper"
		class="org.eurekastreams.server.persistence.mappers.ldap.LdapLookup">
		<constructor-arg ref="ldapGroupDnLdapTemplateRetriever" />
		<constructor-arg ref="findPersonByMembershipFilter" />
		<constructor-arg ref="ldapToPersonCallbackFactory" />
		<constructor-arg ref="pagedLdapSearchStrategy" />
	</bean>

	<!-- End ldap mappers -->
	
	<bean id="getPeopleSkillsByPeopleIdsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetSkillsAndInterestsByEmployeeIdsDbMapper" />
    
    <bean id="getPersonIds" class="org.eurekastreams.server.persistence.mappers.db.GetSerializableField" >
        <constructor-arg value="Person"/>
        <constructor-arg value="id"/>        
    </bean>
    
    <bean id="getGroupIds" class="org.eurekastreams.server.persistence.mappers.db.GetSerializableField" >
        <constructor-arg value="DomainGroup"/>
        <constructor-arg value="id"/>        
    </bean> 
    
    <bean id="getThemeUuidsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetSerializableField" >
        <constructor-arg value="Theme"/>
        <constructor-arg value="uuid"/>        
    </bean>             
    
    <bean id="getPersonsByIdsDBMapper" class="org.eurekastreams.server.persistence.mappers.db.GetPersonsByIds">
        <constructor-arg ref="personQueryStrategy" />
        <constructor-arg ref="getPeopleSkillsByPeopleIdsDbMapper" />
    </bean>  
    
    <bean id="getGroupsByIdsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetGroupsByIdsDbMapper">
        <constructor-arg ref="domainGroupQueryStrategy" />
    </bean>
    
    <bean id="deleteThemeByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.DeleteEntityByIdDbMapper">
        <constructor-arg value="org.eurekastreams.server.domain.Theme" />
    </bean>
    
    <bean id="deleteGalleryTabTemplateByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.DeleteEntityByIdDbMapper">
        <constructor-arg value="org.eurekastreams.server.domain.GalleryTabTemplate" />
    </bean>
    
    <bean id="galleryTabTemplateDTODBMapper" class="org.eurekastreams.server.persistence.GalleryTabTemplateMapper">
        <constructor-arg ref="queryOptimizer" />
    </bean>    
    
    <bean id="deleteStreamDbMapper" class="org.eurekastreams.server.persistence.mappers.db.DeleteStreamDbMapper"/>
        
    <bean id="getPeopleIdsUsingThemeByThemeId" class="org.eurekastreams.server.persistence.mappers.db.GetPeopleIdsUsingThemeByThemeId"/>
    
    <bean id="getThemeXmlUrlByUuidDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetThemeXmlUrlByUuidDbMapper"/>
    
    <bean id="getOrderedCommentIdsByActivityIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetOrderedCommentIdsByActivityIdDbMapper" />
    
    <bean id="getGroupCoordinatorIdsByGroupIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetGroupCoordinatorIdsByGroupIdDbMapper" />
    
    <bean id="getFollowedGroupIdsForPersonByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetFollowedGroupIdsForPersonByIdDbMapper" />
    
    <bean id="getFollowerPersonIdsForGroupByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetFollowerPersonIdsForGroupByIdDbMapper" />    
    
    <bean id="getFollowerPersonIdsForPersonByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetFollowerPersonIdsForPersonByIdDbMapper" />
    
    <bean id="getFollowedPersonIdsForPersonByIdDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetFollowedPersonIdsForPersonByIdDbMapper" />      
    
    <bean id="getListsContainingActivities" class="org.eurekastreams.server.persistence.mappers.db.GetListsContainingActivities" />
	
	<bean id="getActivityIdsPostedToStreamByUniqueKeyAndScopeType" 
	    class="org.eurekastreams.server.persistence.mappers.db.GetActivityIdsPostedToStreamByUniqueKeyAndScopeType" />                

	<bean id="insertRequestForGroupMembershipMapper"
		class="org.eurekastreams.server.persistence.mappers.db.InsertRequestForGroupMembership" />

	<bean id="deleteRequestForGroupMembershipMapper"
		class="org.eurekastreams.server.persistence.mappers.db.DeleteRequestForGroupMembership" />

	<bean id="getRequestsForGroupMembershipMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetRequestsForGroupMembershipByGroup" />

	<bean id="updateGadgetsWithNewTabLayoutMapper"
		class="org.eurekastreams.server.persistence.mappers.db.UpdateGadgetsWithNewTabLayoutMapper" />

	<bean id="getPersonIdsByLockedStatus"
		class="org.eurekastreams.server.persistence.mappers.db.GetPersonIdsByLockedStatus" />

	<bean id="getPersonAccountIdsByLockedStatus"
		class="org.eurekastreams.server.persistence.mappers.db.GetPersonAccountIdsByLockedStatus" />

	<bean id="setPersonLockedStatus"
		class="org.eurekastreams.server.persistence.mappers.db.SetPersonLockedStatus" />

	<bean id="getReadOnlyStreamsDbMapper"
		class="org.eurekastreams.server.persistence.mappers.db.GetReadOnlyStreamsDbMapper" />

    <bean id="getPersonAdditionalProperties" class="org.eurekastreams.server.persistence.mappers.db.GetAllPersonAdditionalProperties" />

	<bean id="getPersonAdditionalPropertiesSingle" class="org.eurekastreams.server.persistence.mappers.db.GetAllPersonAdditionalPropertiesSingle" />    
    
    <bean id="getPersonAvatarId" class="org.eurekastreams.server.persistence.mappers.db.GetAllPersonAvatarId" />

    <bean id="getPersonActivitySubscriptionDbMapper" class="org.eurekastreams.server.persistence.mappers.db.notification.GetStreamActivitySubscriptionDbMapper">
    	<constructor-arg value="PERSON" />
    </bean>

    <bean id="getGroupActivitySubscriptionDbMapper" class="org.eurekastreams.server.persistence.mappers.db.notification.GetStreamActivitySubscriptionDbMapper">
    	<constructor-arg value="GROUP" />
    </bean>

    <bean id="changePersonActivitySubscriptionDbMapper" class="org.eurekastreams.server.persistence.mappers.db.notification.ChangeStreamActivitySubscriptionDbMapper">
    	<constructor-arg value="PERSON" />
    </bean>

    <bean id="changeGroupActivitySubscriptionDbMapper" class="org.eurekastreams.server.persistence.mappers.db.notification.ChangeStreamActivitySubscriptionDbMapper">
    	<constructor-arg value="GROUP" />
    </bean>

    <bean id="findOrInsertSharedResourceByUniqueKeyMapper" class="org.eurekastreams.server.persistence.mappers.db.FindOrInsertSharedResourceByUniqueKeyDbMapper" />

    <bean id="setLikedSharedResourceStatusDbMapper" class="org.eurekastreams.server.persistence.mappers.db.SetLikedSharedResourceStatusDbMapper" />

    <bean id="flushMapper" class="org.eurekastreams.server.persistence.mappers.db.FlushMapper" />
    
    <bean id="clearMapper" class="org.eurekastreams.server.persistence.mappers.db.ClearEntityManagerMapper" />

    <bean id="createGalleryTabTemplateMapper" class="org.eurekastreams.server.action.execution.gallery.GalleryTabTemplateFactory" />
    
    <bean id="membershipCriteriaDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetMembershipCriteriaDBMapper" />

    <bean id="membershipCriteriaDTODbMapper" class="org.eurekastreams.server.persistence.mappers.DomainMapperTransformer">
        <constructor-arg ref="membershipCriteriaDbMapper" />
        <constructor-arg ref="membershipCriteriaListToMembershipCriteriaDTOListTransformer" />
    </bean>

    <bean id="displayInfoSettableDataPopulator" class="org.eurekastreams.server.domain.strategies.DisplayInfoSettableDataPopulator">
        <constructor-arg ref="getPersonsByIdsMapper" />
        <constructor-arg ref="getGroupsByIdsMapper"/>
    </bean>
    
    <bean id="followerStatusPopulator" class="org.eurekastreams.server.domain.strategies.FollowerStatusPopulator">
        <constructor-arg ref="getFollowedPersonIdsForPersonByIdMapper" />
        <constructor-arg ref="getFollowedGroupIdsForPersonByIdMapper"/>
    </bean>
    
    <bean id="membershipCriteriaListToMembershipCriteriaDTOListTransformer"
        class="org.eurekastreams.server.persistence.mappers.cache.MembershipCriteriaListToMembershipCriteriaDTOListTransformer" /> 
        
    <!-- Mapper to get the featured streams from the database, then fill in the display info from cache/db -->
    <bean id="getFeaturedStreamsMapper" class="org.eurekastreams.server.domain.strategies.ChainedMapperWrapperMapper">
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetFeaturedStreamDTOsDbMapper" />
        </constructor-arg>
        <constructor-arg ref="displayInfoSettableDataPopulator" />
    </bean>
        
    <!-- Metrics -->
    <bean id="getUsageMetricSummaryDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetUsageMetricSummaryDbMapper" />
    <bean id="usageMetricStreamSummaryRequestToStreamScopeIdTransformer" class="org.eurekastreams.server.persistence.mappers.db.metrics.UsageMetricStreamSummaryRequestToStreamScopeIdTransformer" />
    <bean id="getUsageMetricSummaryMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
               <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg>
                            <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.STREAM_METRICS_BY_STREAM_SCOPE_ID" />
                        </constructor-arg>
                        <constructor-arg ref="usageMetricStreamSummaryRequestToStreamScopeIdTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper -->
        <constructor-arg ref="getUsageMetricSummaryDbMapper" />
        <!-- Results combiner:  return whichever is not null -->
        <constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache updater -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg>
                    <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.STREAM_METRICS_BY_STREAM_SCOPE_ID" />
                </constructor-arg>
                <constructor-arg ref="usageMetricStreamSummaryRequestToStreamScopeIdTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    <bean id="getUsageMetricSummaryMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper - always returns null, which forces refresh -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper -->
        <constructor-arg ref="getUsageMetricSummaryDbMapper" />
        <!-- Results combiner:  return whichever is not null -->
        <constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache updater -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg>
                    <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.STREAM_METRICS_BY_STREAM_SCOPE_ID" />
                </constructor-arg>
                <constructor-arg ref="usageMetricStreamSummaryRequestToStreamScopeIdTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    
    
    <bean id="getDailyMessageCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyMessageCountDbMapper" />
    <bean id="getDailyMessageResponseTime" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyMessageResponseTime" />
    <bean id="getDailyPageViewCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyPageViewCountDbMapper" />
    <bean id="getDailyStreamContributorCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyStreamContributorCountDbMapper" />
    <bean id="getDailyStreamViewCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyStreamViewCountDbMapper" />
    <bean id="getDailyStreamViewerCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyStreamViewerCountDbMapper" />
    <bean id="getDailyUniqueVisitorCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyUniqueVisitorCountDbMapper" />
    <bean id="getDailyUsageSummaryByDateDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetDailyUsageSummaryByDateDbMapper" />
    <!-- END Metrics -->

    <bean id="dayOfWeekStrategy" class="org.eurekastreams.commons.date.DayOfWeekStrategy" />
    <bean id="getDateFromDaysAgoStrategy" class="org.eurekastreams.commons.date.GetDateFromDaysAgoStrategy" />

    <bean id="personModelViewAvatarDisplayTransformer" class="org.eurekastreams.server.domain.strategies.PersonModelViewAvatarDisplayTransformer"/>

    <!-- Mapper to get PersonModelViews with only the information needed to display avatars -->
    <bean id="getPersonAvatarDisplayInfoByIdsMapper" class="org.eurekastreams.server.persistence.mappers.DomainMapperTransformer">
        <constructor-arg ref="getPersonsByIdsMapper" />
        <constructor-arg ref="personModelViewAvatarDisplayTransformer" />
    </bean>

    <bean id="sharedResourceUniqueKeyToCacheKeySuffixTransformer"
    	class="org.eurekastreams.server.persistence.mappers.cache.SharedResourceUniqueKeyToCacheKeySuffixTransformer" />

    <bean id="sharedResourceRequestToCacheKeySuffixTransformer" 
    	class="org.eurekastreams.server.persistence.mappers.cache.SharedResourceRequestToCacheKeySuffixTransformer">
    	<constructor-arg ref="sharedResourceUniqueKeyToCacheKeySuffixTransformer" />
    </bean>
    
    <bean id="getSharedResourceByKeyDBMapper" class="org.eurekastreams.server.persistence.mappers.GetSharedResourcePropertiesMapper">
        <constructor-arg ref="getStreamScopeForResourceScopeTypeByUniqueKey" />
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetPeopleWhoSharedResourceDbMapper" />
        </constructor-arg>
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetPeopleWhoLikedResourceDbMapper" />
        </constructor-arg>
    </bean>
    <!--
        Mapper to get the cacheable components of a SharedResourceDTO, which is everything except whether the current person liked it, and does not include
        any avatar info for the people that liked it.
     -->
    <bean id="getSharedResourceByKeyMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
               <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg>
                            <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.SHARED_RESOURCE_BY_UNIQUE_KEY" />
                        </constructor-arg>
                        <constructor-arg ref="sharedResourceRequestToCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper -->
        <constructor-arg ref="getSharedResourceByKeyDBMapper" />
        <!-- Results combiner:  return whichever is not null -->
        <constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache updater -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg>
                    <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.SHARED_RESOURCE_BY_UNIQUE_KEY" />
                </constructor-arg>
                <constructor-arg ref="sharedResourceRequestToCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>

    <!-- gets single streamScopeId for resource based on StreamScope uniqueKey, returns null if exactly one result not found. -->
    <bean id="getStreamScopeForResourceScopeTypeByUniqueKey" class="org.eurekastreams.server.persistence.mappers.db.GetStreamScopeForScopeTypeByUniqueKey">
        <constructor-arg>
             <value type="org.eurekastreams.server.domain.stream.StreamScope$ScopeType">RESOURCE</value>
        </constructor-arg>
        <constructor-arg value="false" />
    </bean>

    <!-- gets single streamScopeId for person based on StreamScope uniqueKey, returns null if exactly one result not found. -->
    <bean id="getStreamScopeForPersonScopeTypeByUniqueKey" class="org.eurekastreams.server.persistence.mappers.db.GetStreamScopeForScopeTypeByUniqueKey">
        <constructor-arg>
             <value type="org.eurekastreams.server.domain.stream.StreamScope$ScopeType">PERSON</value>
        </constructor-arg>
        <constructor-arg value="false" />
    </bean>

    <!-- gets single streamScopeId for person based on StreamScope uniqueKey, returns null if exactly one result not found. -->
    <bean id="getStreamScopeForGroupScopeTypeByUniqueKey" class="org.eurekastreams.server.persistence.mappers.db.GetStreamScopeForScopeTypeByUniqueKey">
        <constructor-arg>
             <value type="org.eurekastreams.server.domain.stream.StreamScope$ScopeType">GROUP</value>
        </constructor-arg>
        <constructor-arg value="false" />
    </bean>

    <!-- gets single streamScopeId for resource based on StreamScope uniqueKey, throws exception if exactly one result not found. -->
    <bean id="getStreamScopeForResourceScopeTypeByUniqueKeyExceptionIfNotFound" class="org.eurekastreams.server.persistence.mappers.db.GetStreamScopeForScopeTypeByUniqueKey">
        <constructor-arg>
             <value type="org.eurekastreams.server.domain.stream.StreamScope$ScopeType">RESOURCE</value>
        </constructor-arg>
        <constructor-arg value="true" />
    </bean>

    <!-- gets single activityDTO by id, returns null if exactly one result not found. -->
    <bean id="activityDTOMapper" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
        <constructor-arg ref="bulkActivitiesMapper" />
        <constructor-arg value="false" />
    </bean>

    <!-- gets single activityDTO by id, throws exception if exactly one result not found. -->
    <bean id="activityDTOMapperThrowException" class="org.eurekastreams.server.persistence.mappers.SingleValueCollectionMapperWrapper">
        <constructor-arg ref="bulkActivitiesMapper" />
        <constructor-arg value="true" />
    </bean>

    <bean id="getSystemAdministratorIdsDbMapper" class="org.eurekastreams.server.persistence.mappers.db.GetSystemAdministratorIdsDbMapper" />

    <bean id="getSystemAdministratorIds" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
		        <constructor-arg>
		            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheMapper">
		                <constructor-arg>
	                       <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.SYSTEM_ADMINISTRATOR_IDS" />
	                    </constructor-arg>
		                <constructor-arg ref="ignoredCacheKeySuffixTransformer" />
		                <property name="cache" ref="memcachedCache" />
		            </bean>
		        </constructor-arg>
		    </bean>
        </constructor-arg>
        <!-- Database mapper -->
        <constructor-arg ref="getSystemAdministratorIdsDbMapper" />
         <!-- Results combiner:  return whichever is not null -->
        <constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
	        <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleListValueCacheRefreshStrategy">
	           <constructor-arg>
                    <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.SYSTEM_ADMINISTRATOR_IDS" />
                </constructor-arg>
		        <constructor-arg ref="ignoredCacheKeySuffixTransformer" />
		        <property name="cache" ref="memcachedCache" />
		    </bean>
		</constructor-arg>
    </bean>


    <bean id="getSystemAdministrators" class="org.eurekastreams.server.domain.strategies.ChainedMapperWrapperMapper">
        <!-- Get the system administrator ids -->
        <constructor-arg ref="getSystemAdministratorIds" />

        <!-- And convert those people ids to PersonModelViews -->
        <constructor-arg ref="getPersonsByIdsMapper" />
    </bean>

    <!-- Get the stream scope id for a person by their account id - using cache if available -->
    <bean id="getStreamScopeIdForPersonByUniqueKeyMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.STREAM_SCOPE_ID_BY_PERSON_ACCOUNT_ID" />
                        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetStreamScopeIdForScopeTypeByUniqueKeyDbMapper">
                <constructor-arg>
                    <value type="org.eurekastreams.server.domain.stream.StreamScope$ScopeType">PERSON</value>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
        <constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.STREAM_SCOPE_ID_BY_PERSON_ACCOUNT_ID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>

    <!-- Get the stream scope id for a group by its short name - using cache if available -->
    <bean id="getStreamScopeIdForGroupTypeByUniqueKeyMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache Mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.STREAM_SCOPE_ID_BY_GROUP_SHORT_NAME" />
                        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper to fall back on if not found in cache -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.db.GetStreamScopeIdForScopeTypeByUniqueKeyDbMapper">
		        <constructor-arg>
		            <value type="org.eurekastreams.server.domain.stream.StreamScope$ScopeType">GROUP</value>
		        </constructor-arg>
		    </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
        <constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache refresher -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.STREAM_SCOPE_ID_BY_GROUP_SHORT_NAME" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>


    <!-- **** STREAM DISCOVERY PAGE **** -->
    <!-- This will be refreshed on a crontab -->
    <!-- DB mapper to get all of the lists from the database -->
    <bean id="streamDiscoverListsDbMapper" class="org.eurekastreams.server.persistence.mappers.StreamDiscoverListsMapper">
        <constructor-arg ref="getFeaturedStreamsMapper" />
        <constructor-arg>
            <!-- Most Active Streams (sorted by average daily message count) -->
	        <bean class="org.eurekastreams.server.persistence.mappers.db.metrics.GetStreamsByDailyAverageMessageCountDbMapper">
		        <!-- 200 = 20 pages of data that will be sent to the client -->
		        <constructor-arg value="200" />
		    </bean>
        </constructor-arg>
        <constructor-arg>
            <!-- Most viewed streams (sorted by average daily viewers) -->
		    <bean class="org.eurekastreams.server.persistence.mappers.db.metrics.GetStreamsByDailyAverageViewersDbMapper">
		        <constructor-arg value="10" />
		    </bean>
        </constructor-arg>
        <constructor-arg>
            <!-- Most followed streams (sorted by the current follow count) -->
		    <bean id="getStreamsByFollowersCountDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetStreamsByFollowersCountDbMapper">
		        <constructor-arg value="10" />
		    </bean>
        </constructor-arg>
        <constructor-arg>
            <!-- Most recent streams (sorted by created date) -->
		    <bean id="getStreamsByMostRecentDbMapper" class="org.eurekastreams.server.persistence.mappers.db.metrics.GetStreamsByMostRecentDbMapper">
		        <constructor-arg value="10" />
		    </bean>
        </constructor-arg>
        <constructor-arg ref="repopulateTempWeekdaysSinceDateStrategy" />
        <!-- Calculate the number of weekdays since today for the past 30 days -->
        <constructor-arg value="30" />
    </bean>
    <bean id="streamDiscoverListsMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg>
                            <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.DISCOVERY_PAGE_LISTS" />
                        </constructor-arg>
                        <constructor-arg ref="ignoredCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Database mapper -->
        <constructor-arg ref="streamDiscoverListsDbMapper" />
        <!-- Results combiner:  return whichever is not null -->
        <constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache updater -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg>
                    <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.DISCOVERY_PAGE_LISTS" />
                </constructor-arg>
                <constructor-arg ref="ignoredCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    <bean id="streamDiscoverListsMapper_FORCE_REFRESH" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper - always returns null, which forces refresh -->
        <constructor-arg ref="nullResultPartialMapper"/>
        <!-- Database mapper -->
        <constructor-arg ref="streamDiscoverListsDbMapper" />
        <!-- Results combiner:  return whichever is not null -->
        <constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache updater -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg>
                    <util:constant static-field="org.eurekastreams.server.persistence.mappers.cache.CacheKeys.DISCOVERY_PAGE_LISTS" />
                </constructor-arg>
                <constructor-arg ref="ignoredCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>
    
    <bean id="getSuggestedPeopleMapper" class="org.eurekastreams.server.persistence.mappers.db.GetSuggestedPeopleForPersonDbMapper" />
    <bean id="getSuggestedGroupsMapper" class="org.eurekastreams.server.persistence.mappers.db.GetSuggestedGroupsForPersonDbMapper" />
    
    <bean id="deleteAllTempWeekdaysSinceDateDbMapper" class="org.eurekastreams.server.persistence.mappers.db.DeleteAllTempWeekdaysSinceDateDbMapper" />
    
    <bean id="repopulateTempWeekdaysSinceDateStrategy" class="org.eurekastreams.server.service.actions.strategies.RepopulateTempWeekdaysSinceDateStrategy">
    	<constructor-arg>
    		<bean class="org.eurekastreams.commons.date.WeekdaysInDateRangeStrategy" />
    	</constructor-arg>
    	<constructor-arg ref="getDateFromDaysAgoStrategy"/>
   		<constructor-arg ref="deleteAllTempWeekdaysSinceDateDbMapper" />
		<constructor-arg>
			<bean class="org.eurekastreams.server.persistence.mappers.InsertMapper" />
		</constructor-arg>
		<constructor-arg ref="flushMapper" />		
    </bean>
    
    <bean id="getAllGroupSubscribersDao" class="org.eurekastreams.server.persistence.mappers.db.GenericGetListDbMapper">
    	<constructor-arg value="SELECT gf.pk.followerId FROM GroupFollower gf WHERE gf.pk.followingId = :id AND gf.receiveNewActivityNotifications = true" />
    </bean>
    
    <bean id="getUnrestrictedGroupSubscribersDao" class="org.eurekastreams.server.persistence.mappers.db.GenericGetListDbMapper">
    	<constructor-arg value="SELECT gf.pk.followerId FROM GroupFollower gf WHERE gf.pk.followingId = :id AND gf.receiveNewActivityNotifications = true AND gf.coordinatorOnlyNotifications = false" />
    </bean>

	<bean id="getActivePersonIdByEmail" class="org.eurekastreams.server.persistence.mappers.db.GetFieldFromTableByUniqueField">
       	<constructor-arg value="Person" />
       	<constructor-arg value="email" />
       	<constructor-arg value="id" />
       	<constructor-arg value="accountLocked = FALSE" />
	</bean>
  
    <bean id="getPersonCryptoKeyMapper" class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
        <!-- Cache mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
                <constructor-arg>
                    <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheMapper">
                        <constructor-arg ref="CacheKeys.CRYPTO_KEY_BY_PERSON_ID" />
                        <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                        <property name="cache" ref="memcachedCache" />
                    </bean>
                </constructor-arg>
            </bean>
        </constructor-arg>
        <!-- Chained/decorated/inner mapper -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.chained.DecoratedPartialResponseDomainMapper">
		        <!-- Database mapper -->
		        <constructor-arg>
		            <bean class="org.eurekastreams.server.persistence.mappers.chained.PartialMapperWrapper">
		                <constructor-arg>
		                    <bean class="org.eurekastreams.server.persistence.mappers.db.PersonCryptoKeyDbMapper"/>
		                </constructor-arg>
		            </bean>
		        </constructor-arg>
		        <!-- Creator mapper -->
		        <constructor-arg>
		        	<bean class="org.eurekastreams.server.persistence.mappers.CreateCryptoKeyMapper">
		        		<constructor-arg ref="cryptoKeyGenerator" />
		        	</bean>
		        </constructor-arg>
		        <!-- Results combiner:  return whichever is not null -->
		        <constructor-arg ref="nonNullResultsCombiner" />
		        <!-- Database updater -->
		        <constructor-arg>
		            <bean class="org.eurekastreams.server.persistence.mappers.db.PersonCryptoKeyDbRefreshStrategy" />
		        </constructor-arg>
		    </bean>
        </constructor-arg>
        <!-- Results combiner:  return whichever is not null -->
        <constructor-arg ref="nonNullResultsCombiner" />
        <!-- Cache updater -->
        <constructor-arg>
            <bean class="org.eurekastreams.server.persistence.mappers.cache.SingleValueCacheRefreshStrategy">
                <constructor-arg ref="CacheKeys.CRYPTO_KEY_BY_PERSON_ID" />
                <constructor-arg ref="toStringCacheKeySuffixTransformer" />
                <property name="cache" ref="memcachedCache" />
            </bean>
        </constructor-arg>
    </bean>

	<bean id="cryptoKeyGenerator" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean">
		<property name="targetClass" value="javax.crypto.KeyGenerator" />
		<property name="targetMethod" value="getInstance" />
		<property name="arguments">
			<list>
				<value>${eureka.crypto.algorithm}</value>
			</list>
		</property>
	</bean>

</beans>
